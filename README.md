# TG_BOT_TRANSLATOR - бот переводчик
Бот переведет ваше любое ваше слово которое вы ему напишете, на поддерживаемые языки

## Задача 1: Создание скелета бота
1) Реализовать простейшие команды:
- `/about` - выводит краткую информацию о боте
- `/authors` - выводит авторов бота
- `/help` - выводит информацию о всех командах бота, в том числе и о себе(/help argument)

Вклад: 

**Богданов**: ознакомился с документацией ТГ API, зарегистрировал токен бота, сделал команды /about и /help, абстрактный класс AbstractCommand, интерфейс Command для всех команд, сделал класс TelegramBot чтобы бот мог запускаться для проверки работоспособности(бот мог только повторять последнее, что ему отправили), написал тесты для команды help

**Дерябин**: Реализовал /authors, /echo, Command Manager с помощью которого выводятся все существующие команды через /help, обновил класс TelegramBot, чтобы тот мог исправно работать со всеми добавленными командами, создал main для исправного запуска бота, сделал тесты для CommandManager и EchoCommand

## Задача 2: Подключение Gemini к боту через токен, команда для перевода и команда для выбора языка с которого нужно переводить
1) Получение токена:
- получение токена через Google AI Studio
- подключение бота к Gemini через токен
2) Команды для перевода:
- `/setlanguage` - устанавливает язык с которого нужно переводить (/setlanguage agr)
- `/translate` - переводит слово на русский, с указанного языка (/translate textToTranslate LanguageToTranslate)

Вклад:

**Богданов**: получил токен для взаимодействия с Gemini, сделал класс GeminiService, через который реализовывалась отправка запросов к Gemini через JSON. Класс Config в котором содержится токены бота и Gemini, название бота, модель используемой Gemini, для удобства, чтобы можно было менять модель изменив одну переменную. Сделал класс TranslateCommand, который отправлял запрос Gemini на перевод, сделал тест на TranslateCommand, GeminiService, написал класс SetLanguageCommand с пустыми методами.


**Дербяин**: написал SetLanguageCommand через Map с поддержкой языков: Русский, Английский, Немецкий, Испанский, Французский. Дописал CommandManger, TelegramBot, переписал main, чтобы бот корректно работал с Gemini. Написал тесты для SetLanguageCommand, CommandManager  

## Задача 3: Подключение Базы Данных
1) Создать класс для базы данных, обновить существующие для работы с БД, статистика сохраняется в отдельном файле. БД сделана через SQlite.
2) Команда, которая выводит статистику переводов пользователя.
3) Запоминание последнего языка перевода, чтобы автоматически переводить введенный текст.
4) Вывод логов в терминал

**Богданов**: ЛОГИ: обновил **TelegramBot**, **main**, **DatabaseManager**, **GeminiService**, для вывода успешно ли создалась БД, подключен ли Gemini и тд. Создал класс **DatabaseManager**, который создавал таблицы со статистикой,в БД есть таблица сохраняющая последний язык для перевода. Обновил **TranslateCommand** под БД(теперь команда может использоваться без аргумента LanguageToTranslate). В последствии создал класс **SetTranslationCommand**, которая сделала возможным переводить слова не только на русский. Сделал тесты на SetTranslateCommand

**Дерябин**: Обновил **setLanguageCommand** для работы с БД, обновил, создал команду `/profile`, которая брала id чата и по нему из базы данных выводила статистику переводов. Обновил **CommandManager** под базу данных. Создал класс AutoTranslateService которая автоматически переводила введенный текст, если там не присутствует команд, берет из таблицы с последним языком перевода БД. 

## Задача 4: Многопоточность:
1) реализовать асинхронную обработку сообщений
2) RateLimiting для API запросов
3) кеширование результатов команд и переводов
4) Пул потоков с настраиваемыми параметрами
5) очередь отправки сообщений с повторными попытками
6) сделать вывод статистику потоков в отдельный файл

**Богданов**: 
    придумал схему реализации данной задачи:
    
    1) Получение Update от Телеграм
    2) AsyncMessageHandler проверяет сообщение на кулдаун(1 секунда)
    3) Проверка на RateLimit, если превышен, то отправляется предупреждение
    4) ThreadPoolManager -> submitTask
    5) Проверка кеша, если ответ кеширован, то выдается сразу
    6) если нет, то идет дальше на обработку, берется ответ от Gemini и после кешируется

Реализовал AsyncMessageHandler, и очередь пула потоков для него(MessageQueueService), сделал класс CacheService для кэширования ответов, сделал класс InlineSuggestionsService для кнопок в чате с ботом, кнопка меню, и кнопки для быстрой отправки команд.

**Дерябин**: сделал класс RateLimitingService для установления ограничения сообщений, дописал Config, где задаются ограничения, реализовал класс TreadPoolManager, который управляет потоками. Сделал тесты на ThreadPoolManager, RateLimiterService.